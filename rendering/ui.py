"""UI module for 2048."""
import os
import pygame as pg
#pylint: disable=E0401
from game.board import Board
from game import utils as ut
from rendering.animation import TileAnimation

#pylint: disable=no-member
pg.init()


class GameUI:  # pylint: disable=too-many-instance-attributes
    """Handles all the visual rendering and animations for the game."""
    # @generated "partially" gemini -3 pro - some functions were generated by AI

    def __init__(self, size, ui_board: Board):
        self.size = size
        self.board = ui_board

        # make sure the window pops up in the center of the screen
        
        # @generated "all" gemini -3 pro - the next 2 lines were generated by AI, to figure out how to center the window
        if 'SDL_VIDEO_CENTERED' not in os.environ:
            os.environ['SDL_VIDEO_CENTERED'] = '1'

        self.screen = pg.display.set_mode((ut.SCREEN_HEIGHT, ut.SCREEN_WIDTH))
        pg.display.set_caption("2048")

        self.old_grid = None
        # figure out how big everything should be
        tile_size, start_x, start_y, grid_width, grid_height = ut.get_grid_dimensions(self.size)
        self.tile_size = int(tile_size)

        # create the background panel for the grid
        self.grid_bg_rect = pg.Rect(start_x, start_y, grid_width, grid_height)

        # get the layout for score boxes and title
        self.layout = ut.calculate_ui_layout(start_x, grid_width)

        # set up all the fonts we'll need
        self.label_font = pg.font.SysFont("Arial", ut.LABEL_FONT_SIZE, bold=True)
        self.score_font = pg.font.SysFont("Arial", ut.SCORE_FONT_SIZE, bold=True)
        self.title_font = pg.font.SysFont("Comic Sans MS", ut.TITLE_FONT_SIZE, bold=True)
        self.tile_font = pg.font.SysFont("Comic Sans MS", int(self.tile_size // 2), bold=True)
        self.game_over_font = pg.font.SysFont("Comic Sans MS", ut.GAME_OVER_FONT_SIZE, bold=True)
        self.difficulty_font = pg.font.SysFont("Arial", 14, bold=True)

        # create rectangles for each tile position
        self.rects = []
        for i in range(self.size):
            for j in range(self.size):
                x = start_x + ut.TILE_GAP + j * (tile_size + ut.TILE_GAP)
                y = start_y + ut.TILE_GAP + i * (tile_size + ut.TILE_GAP)
                self.rects.append(pg.Rect(x, y, tile_size, tile_size))

        # keep track of active animations
        self.animations = []
        self.animation_duration = 150  # how long animations take in milliseconds

    def draw_tiles(self):
        """Draw all game tiles."""
        # draw the stationary tiles first
        for i in range(self.size):
            for j in range(self.size):
                idx = i * self.size + j
                value = self.board.grid[i][j]

                # don't draw tiles that are currently sliding around
                if any(anim.value == value and anim.end_rect == self.rects[idx]
                       for anim in self.animations):
                    continue

                # draw the tile background
                color = ut.get_tile_color(value)
                pg.draw.rect(self.screen, color, self.rects[idx], border_radius=8)

                # put the number on it if it's not empty
                if value != 0:
                    text_color = ut.get_tile_text_color(value)
                    text = self.tile_font.render(str(value), True, text_color)
                    text_rect = text.get_rect(center=self.rects[idx].center)
                    self.screen.blit(text, text_rect)

        # draw animated tiles on top so they look smooth
        self.draw_animated_tiles()

    def draw_animated_tiles(self):
        """Draw all tiles that are currently animating."""
        for anim in self.animations:
            current_rect = anim.get_current_rect()
            scale = anim.get_scale()

            # make it bigger or smaller based on animation type
            scaled_width = current_rect.width * scale
            scaled_height = current_rect.height * scale
            scaled_rect = pg.Rect(
                current_rect.centerx - scaled_width / 2,
                current_rect.centery - scaled_height / 2,
                scaled_width,
                scaled_height
            )

            # draw the tile
            color = ut.get_tile_color(anim.value)
            pg.draw.rect(self.screen, color, scaled_rect, border_radius=8)

            # draw the number
            if anim.value != 0:
                text_color = ut.get_tile_text_color(anim.value)
                font_size = int(self.tile_size // 2 * scale)
                font = pg.font.SysFont("Comic Sans MS", font_size, bold=True)
                text = font.render(str(anim.value), True, text_color)
                text_rect = text.get_rect(center=scaled_rect.center)
                self.screen.blit(text, text_rect)

    def update_animations(self):
        """Update and remove finished animations."""
        self.animations = [anim for anim in self.animations if not anim.is_finished()]

    def add_animation(self, tile_value, start_idx, end_idx, anim_type='slide'):
        """Add a new tile animation."""
        anim = TileAnimation(
            tile_value,
            self.rects[start_idx],
            self.rects[end_idx],
            anim_type,
            self.animation_duration
        )
        self.animations.append(anim)

    def has_active_animations(self):
        """Check if any animations are currently running."""
        return len(self.animations) > 0

    def draw_title(self):
        """Draw the 2048 title box."""
        title_data = self.layout['title']
        title_rect = pg.Rect(title_data['rect'])

        pg.draw.rect(self.screen, title_data['color'], title_rect, border_radius=8)

        title_text = self.title_font.render("2048", True, title_data['text_color'])
        text_rect = title_text.get_rect(center=title_rect.center)
        self.screen.blit(title_text, text_rect)

    def draw_score_box(self):
        """Draw the score box."""
        score_data = self.layout['score']
        score_rect = pg.Rect(score_data['rect'])

        # draw the background
        pg.draw.rect(self.screen, score_data['color'], score_rect, border_radius=5)

        # add the "SCORE" label
        label = self.label_font.render("SCORE", True, score_data['label_color'])
        label_rect = label.get_rect(centerx=score_rect.centerx, top=score_rect.top + 8)
        self.screen.blit(label, label_rect)

        # show the actual score
        score_text = self.score_font.render(str(self.board.score), True, score_data['text_color'])
        text_rect = score_text.get_rect(centerx=score_rect.centerx, bottom=score_rect.bottom - 10)
        self.screen.blit(score_text, text_rect)

    def draw_highscore_box(self):
        """Draw the highscore box."""
        highscore_data = self.layout['highscore']
        highscore_rect = pg.Rect(highscore_data['rect'])

        # draw the background
        pg.draw.rect(self.screen, highscore_data['color'], highscore_rect, border_radius=5)

        # add the "BEST" label
        label = self.label_font.render("BEST", True, highscore_data['label_color'])
        label_rect = label.get_rect(centerx=highscore_rect.centerx, top=highscore_rect.top + 8)
        self.screen.blit(label, label_rect)

        # show the high score
        highscore_text = self.score_font.render(
            str(self.board._highscore), True,  # pylint: disable=protected-access
            highscore_data['text_color']
        )
        text_rect = highscore_text.get_rect(
            centerx=highscore_rect.centerx,
            bottom=highscore_rect.bottom - 10
        )
        self.screen.blit(highscore_text, text_rect)

    def draw_difficulty_indicator(self):
        """Draw difficulty indicator below title."""
        title_data = self.layout['title']
        title_rect = pg.Rect(title_data['rect'])

        # get the current difficulty
        difficulty = self.board.difficulty.upper()

        # color code each difficulty
        difficulty_colors = {
            'EASY': (46, 204, 113),
            'MEDIUM': (52, 152, 219),
            'HARD': (231, 76, 60)
        }

        color = difficulty_colors.get(difficulty, (119, 110, 101))

        # make a nice badge for it
        badge_width = 120
        badge_height = 25
        badge_x = title_rect.centerx - badge_width // 2
        badge_y = title_rect.bottom + 10
        badge_rect = pg.Rect(badge_x, badge_y, badge_width, badge_height)

        # draw the badge
        pg.draw.rect(self.screen, color, badge_rect, border_radius=4)

        # add the text
        diff_text = self.difficulty_font.render(difficulty, True, (255, 255, 255))
        text_rect = diff_text.get_rect(center=badge_rect.center)
        self.screen.blit(diff_text, text_rect)

    def draw(self):
        """Draw the complete game state."""

        self.screen.fill(ut.BACKGROUND_COLOR)

        self.draw_title()
        self.draw_difficulty_indicator()  # show what difficulty they picked
        self.draw_score_box()
        self.draw_highscore_box()

        # draw the background panel behind the tiles
        pg.draw.rect(self.screen, ut.GRID_BACKGROUND_COLOR, self.grid_bg_rect, border_radius=8)

        self.draw_tiles()
        self.update_animations()

        if self.board.won and not self.board.game_over:
            self.draw_win_screen()
        elif self.board.game_over:
            self.draw_game_over()

        pg.display.update()

    def draw_game_over(self):  # pylint: disable=too-many-locals
        # @generated "all" gemini -3 pro - this entire function was generated by AI

        """Draw game over overlay with options to restart."""
        overlay = pg.Surface((ut.SCREEN_WIDTH, ut.SCREEN_HEIGHT), pg.SRCALPHA)
        overlay.fill((0, 0, 0, 200))  # semi-transparent dark overlay

        # set up all the fonts we need
        game_over_font = pg.font.SysFont("Comic Sans MS", 80, bold=True)
        score_font = pg.font.SysFont("Arial", 36, bold=True)
        instruction_font = pg.font.SysFont("Arial", 24)
        small_font = pg.font.SysFont("Arial", 18, italic=True)

        # big "GAME OVER" text
        text = game_over_font.render("GAME OVER", True, (255, 100, 100))
        text_rect = text.get_rect(center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 - 100))

        # show their final score
        final_score = score_font.render(f"Final Score: {self.board.score}", True, (255, 255, 255))
        score_rect = final_score.get_rect(center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 - 20))

        # celebrate if they beat their high score
        if self.board.score == self.board._highscore:  # pylint: disable=protected-access
            new_best = small_font.render("NEW HIGH SCORE!", True, (255, 215, 0))
            best_rect = new_best.get_rect(center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 20))
        else:
            high_score_text = small_font.render(
                f"High Score: {self.board._highscore}",  # pylint: disable=protected-access
                True, (200, 200, 200)
            )
            best_rect = high_score_text.get_rect(
                center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 20)
            )

        # tell them how to play again
        instruction1 = instruction_font.render("Press any key to play again", True, (255, 255, 255))
        instruction1_rect = instruction1.get_rect(
            center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 80)
        )

        instruction2 = small_font.render("(You'll choose difficulty again)", True, (180, 180, 180))
        instruction2_rect = instruction2.get_rect(
            center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 110)
        )

        # put everything on screen
        self.screen.blit(overlay, (0, 0))
        self.screen.blit(text, text_rect)
        self.screen.blit(final_score, score_rect)

        if self.board.score == self.board._highscore:  # pylint: disable=protected-access
            self.screen.blit(new_best, best_rect)
        else:
            self.screen.blit(high_score_text, best_rect)

        self.screen.blit(instruction1, instruction1_rect)
        self.screen.blit(instruction2, instruction2_rect)

    def draw_win_screen(self):  # pylint: disable=too-many-locals
        # @generated "all" gemini -3 pro - this entire function was generated by AI

        """Draw winning overlay when player reaches 2048."""
        overlay = pg.Surface((ut.SCREEN_WIDTH, ut.SCREEN_HEIGHT), pg.SRCALPHA)
        overlay.fill((255, 215, 0, 180))  # golden semi-transparent overlay

        # set up fonts
        win_font = pg.font.SysFont("Comic Sans MS", 90, bold=True)
        subtitle_font = pg.font.SysFont("Arial", 40, bold=True)
        score_font = pg.font.SysFont("Arial", 32, bold=True)
        instruction_font = pg.font.SysFont("Arial", 24)
        small_font = pg.font.SysFont("Arial", 18, italic=True)

        # big celebration text
        text = win_font.render("YOU WIN!", True, (255, 255, 255))
        text_rect = text.get_rect(center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 - 130))

        # tell them what they did
        subtitle = subtitle_font.render("You reached 2048!", True, (255, 255, 255))
        subtitle_rect = subtitle.get_rect(center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 - 60))

        # show their score
        final_score = score_font.render(f"Score: {self.board.score}", True, (255, 255, 255))
        score_rect = final_score.get_rect(center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 10))

        # show high score
        high_score_text = small_font.render(
            f"High Score: {self.board._highscore}",  # pylint: disable=protected-access
            True, (240, 240, 240)
        )
        best_rect = high_score_text.get_rect(
            center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 45)
        )

        # give them options
        instruction1 = instruction_font.render(
            "Press SPACE to continue playing", True, (255, 255, 255)
        )
        instruction1_rect = instruction1.get_rect(
            center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 100)
        )

        instruction2 = instruction_font.render(
            "Press any other key to restart", True, (255, 255, 255)
        )
        instruction2_rect = instruction2.get_rect(
            center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 135)
        )

        instruction3 = small_font.render("(Choose difficulty again)", True, (220, 220, 220))
        instruction3_rect = instruction3.get_rect(
            center=(ut.SCREEN_WIDTH // 2, ut.SCREEN_HEIGHT // 2 + 165)
        )

        # draw everything
        self.screen.blit(overlay, (0, 0))
        self.screen.blit(text, text_rect)
        self.screen.blit(subtitle, subtitle_rect)
        self.screen.blit(final_score, score_rect)
        self.screen.blit(high_score_text, best_rect)
        self.screen.blit(instruction1, instruction1_rect)
        self.screen.blit(instruction2, instruction2_rect)
        self.screen.blit(instruction3, instruction3_rect)

    def visualize(self):
        """Main game loop (for testing)."""
        run = True
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
            self.draw()

    def prepare_move(self):
        """Store current grid state before a move."""
        self.old_grid = self.board.grid.copy()

    def animate_move(self):
        """Create animations for tile movements after a move."""
        if self.old_grid is None:
            return

        # figure out which tiles moved and where they went
        movements = self._find_tile_movements(self.old_grid, self.board.grid)
        for value, old_idx, new_idx in movements:
            self.add_animation(value, old_idx, new_idx, 'slide')

    def animate_spawn(self):
        """Create animation for newly spawned tile."""
        if self.old_grid is None:
            return

        # find the new tile that just appeared
        for i in range(self.size):
            for j in range(self.size):
                idx = i * self.size + j
                if self.old_grid[i, j] == 0 and self.board.grid[i, j] != 0:
                    value = self.board.grid[i, j]
                    self.add_animation(value, idx, idx, 'spawn')
                    return

    def _find_tile_movements(self, old_grid, new_grid):
        """Find which tiles moved and where they went."""
        movements = []
        matched_new = set()

        for old_i in range(self.size):
            for old_j in range(self.size):
                old_idx = old_i * self.size + old_j
                old_value = old_grid[old_i, old_j]

                if old_value == 0:
                    continue

                # find where this tile ended up
                movement = self._find_single_tile_movement(
                    old_value, old_idx, new_grid, matched_new
                )
                if movement:
                    movements.append(movement)
                    matched_new.add(movement[2])  # add new_idx to matched

        return movements

    def _find_single_tile_movement(self, old_value, old_idx, new_grid, matched_new):
        """Find where a single tile moved to."""
        for new_i in range(self.size):
            for new_j in range(self.size):
                new_idx = new_i * self.size + new_j
                new_value = new_grid[new_i, new_j]

                if new_idx in matched_new:
                    continue

                # check if this is where our tile went (or merged)
                if new_value in (old_value, old_value * 2):
                    if old_idx != new_idx:
                        return (old_value, old_idx, new_idx)
        return None


if __name__ == "__main__":
    board = Board(4)
    game_ui = GameUI(4, board)
    game_ui.visualize()
